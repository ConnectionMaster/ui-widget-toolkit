(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ag-grid-community"), require("es6-promise"));
	else if(typeof define === 'function' && define.amd)
		define("UWT", ["ag-grid-community", "es6-promise"], factory);
	else if(typeof exports === 'object')
		exports["UWT"] = factory(require("ag-grid-community"), require("es6-promise"));
	else
		root["UWT"] = factory(root["agGrid"], root["es6-promise"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ag_grid_community__, __WEBPACK_EXTERNAL_MODULE_es6_promise__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/build/export.grid.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/build/export.grid.ts":
/*!**********************************!*\
  !*** ./src/build/export.grid.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ../interface/ui-base */ \"./src/interface/ui-base.ts\"));\n__export(__webpack_require__(/*! ../interface/grid */ \"./src/interface/grid.ts\"));\n__export(__webpack_require__(/*! ../core/element-manager */ \"./src/core/element-manager.ts\"));\n__export(__webpack_require__(/*! ../core/color-manager */ \"./src/core/color-manager.ts\"));\n__export(__webpack_require__(/*! ../core/utilities */ \"./src/core/utilities.ts\"));\n__export(__webpack_require__(/*! ../core/web-utilities */ \"./src/core/web-utilities.ts\"));\n__export(__webpack_require__(/*! ../core/ag-grid/ag-grid-renderer */ \"./src/core/ag-grid/ag-grid-renderer.ts\"));\n\n\n//# sourceURL=webpack://UWT/./src/build/export.grid.ts?");

/***/ }),

/***/ "./src/core/ag-grid/ag-grid-renderer.ts":
/*!**********************************************!*\
  !*** ./src/core/ag-grid/ag-grid-renderer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ui_base_1 = __webpack_require__(/*! ../../interface/ui-base */ \"./src/interface/ui-base.ts\");\nconst utilities_1 = __webpack_require__(/*! ../utilities */ \"./src/core/utilities.ts\");\nconst color_manager_1 = __webpack_require__(/*! ../color-manager */ \"./src/core/color-manager.ts\");\nconst context_menu_1 = __webpack_require__(/*! ../context-menu */ \"./src/core/context-menu.ts\");\nconst agGrid = __webpack_require__(/*! ag-grid-community */ \"ag-grid-community\");\n// from https://www.ag-grid.com/best-javascript-data-grid/#gsc.tab=0\nfunction percentCellRenderer(params) {\n    var value = params.value;\n    if (value === undefined || value === null) {\n        value = 0;\n    }\n    var percentBar = document.createElement('div');\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.width = value + '%';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.innerHTML = value.toFixed(2) + '%';\n    return percentBar;\n}\nexports.percentCellRenderer = percentCellRenderer;\nfunction computeMaxAndPercentage(rowData, columns) {\n    let columnMax = {};\n    let total = {};\n    for (let i = 0; i < columns.length; ++i) {\n        let column = columns[i];\n        if (!columnMax[column.field]) {\n            columnMax[column.field] = 0;\n        }\n        if (!total[column.field]) {\n            total[column.field] = 0;\n        }\n        for (let j = 0; j < rowData.length; ++j) {\n            if (rowData[j][column.field]) {\n                if (rowData[j][column.field].value) {\n                    rowData[j][column.field] = rowData[j][column.field].value;\n                }\n                columnMax[column.field] = Math.max(columnMax[column.field], rowData[j][column.field]);\n                total[column.field] += rowData[j][column.field];\n            }\n        }\n    }\n    for (let i = 0; i < columns.length; ++i) {\n        let column = columns[i];\n        for (let j = 0; j < rowData.length; ++j) {\n            rowData[j][column.field] = {\n                value: rowData[j][column.field],\n                columnMax: columnMax[column.field],\n                total: total[column.field]\n            };\n        }\n    }\n}\nexports.computeMaxAndPercentage = computeMaxAndPercentage;\nfunction valueCellRenderer(params) {\n    let value = params.value;\n    value.value = value.value ? value.value : 0;\n    let percentBar = document.createElement('div');\n    let barWidth = value.columnMax ? (value.value / value.columnMax * 100) : 0;\n    let percent = value.total ? (value.value / value.total * 100) : 0;\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.style.width = barWidth + '%';\n    if (params.colDef.showAsPercentage) {\n        percentBar.innerHTML = percent.toFixed(2) + '%';\n        percentBar.title = percent.toFixed(2) + '% (' + 'Value: ' + value.value + ')';\n    }\n    else {\n        percentBar.innerHTML = value.value.toFixed(2);\n        percentBar.title = 'Value: ' + value.value + ' (' + percent.toFixed(2) + '%)';\n    }\n    return percentBar;\n}\nexports.valueCellRenderer = valueCellRenderer;\nfunction valueComparator(valueA, valueB, nodeA, nodeB, isInverted) {\n    return valueA.value - valueB.value;\n}\nexports.valueComparator = valueComparator;\nexports.menuItemShowAsPercentage = {\n    title: 'Display Percentage', action: function (elem, data, index) {\n        let idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n        data.colDef.contextMenuItems[idx] = exports.menuItemShowAsTotal;\n        data.colDef.showAsPercentage = true;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nexports.menuItemShowAsTotal = {\n    title: 'Display Raw Values', action: function (elem, data, index) {\n        let idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n        data.colDef.contextMenuItems = [exports.menuItemShowAsPercentage];\n        data.colDef.showAsPercentage = false;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nclass AgGrid {\n    /**\n     * Append the div for this graph to the parent div. The div we create\n     * will be filled when Render() is called\n     *\n     * @param parent - The div that will contain the div for this chart.\n     *\n     * @return - The chart instance\n     */\n    constructor(element, renderer, parent, options = {}) {\n        this._element = element;\n        this._renderer = renderer;\n        this._options = options;\n        this._disableCallbacks = false;\n        if (parent) {\n            this._div = document.querySelector(parent);\n        }\n        let self = this;\n        let defaultCallback = function (row, eventType, callback) {\n            if (self._disableCallbacks) {\n                return;\n            }\n            let grid = self._element;\n            let gridOptions = grid.gridOptions;\n            if (callback) {\n                let columns = gridOptions.columnApi.getAllColumns();\n                if (columns && columns.length > 0) {\n                    let key = columns[0].colDef.field;\n                    let selection = row.node.data[key];\n                    let event = {\n                        caller: grid,\n                        selection: selection,\n                        event: eventType,\n                        data: { row: row }\n                    };\n                    callback(event);\n                }\n            }\n        };\n        this.onRowFocusDefaultCallback = function (row) {\n            defaultCallback(row, ui_base_1.EventType.HoverStart, self._element.onHover);\n        };\n        this.onRowUnfocusDefaultCallback = function (row) {\n            defaultCallback(row, ui_base_1.EventType.HoverEnd, self._element.onHover);\n        };\n        this.onRowSelectedDefaultCallback = function (row) {\n            let eventType = row.node.isSelected() ?\n                ui_base_1.EventType.SelectAdd : ui_base_1.EventType.SelectRemove;\n            defaultCallback(row, eventType, self._element.onClick);\n        };\n        this.api = {\n            select: self.select,\n            hover: self.select\n        };\n        this.keyboardSelectionFocus = function (params) {\n            var previousCell = params.previousCellDef;\n            var suggestedNextCell = params.nextCellDef;\n            var KEY_UP = 38;\n            var KEY_DOWN = 40;\n            var KEY_LEFT = 37;\n            var KEY_RIGHT = 39;\n            let columns = self._element.gridOptions.columnApi.getAllColumns();\n            if (columns && columns.length > 0) {\n                let selectionKey = self._element.gridOptions.selectionKey ?\n                    self._element.gridOptions.selectionKey : columns[0].colDef.field;\n                let helper = function (index) {\n                    previousCell = params.previousCellDef;\n                    // set selected cell on current cell + 1\n                    self._element.gridOptions.api.forEachNode((node) => {\n                        if (index === node.rowIndex) {\n                            node.setSelected(true);\n                        }\n                        else if (!params.event.shiftKey) {\n                            self._renderer.focus(self._element, {\n                                event: ui_base_1.EventType.HoverEnd,\n                                selection: utilities_1.getSelectionName(node.data[selectionKey])\n                            });\n                        }\n                    });\n                    return suggestedNextCell;\n                };\n                switch (params.key) {\n                    case KEY_DOWN:\n                        return helper(previousCell.rowIndex + 1);\n                    case KEY_UP:\n                        return helper(previousCell.rowIndex - 1);\n                    case KEY_LEFT:\n                    case KEY_RIGHT:\n                        return suggestedNextCell;\n                    default:\n                        throw \"this will never happen, navigation is always on of the 4 keys above\";\n                }\n            }\n        };\n    }\n    setDiv(div) {\n        this._div = div;\n    }\n    select(event) {\n        let self = this;\n        let selection = event.selection;\n        // make typescript happy to hardcode some things\n        let gridOptions = this._element.gridOptions;\n        let columns = gridOptions.columnApi.getAllColumns();\n        self._disableCallbacks = true;\n        if (columns && columns.length > 0) {\n            let selectionKey = gridOptions.selectionKey ? gridOptions.selectionKey :\n                columns[0].colDef.field;\n            let key = event.selectionKey ? event.selectionKey : selectionKey;\n            if (event.event === ui_base_1.EventType.SelectAdd ||\n                event.event === ui_base_1.EventType.HoverStart) {\n                this._prevSelection = event.selection;\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key]) === utilities_1.getSelectionName(selection)) {\n                        // select the node\n                        rowNode.setSelected(true);\n                        if (self._element.gridOptions.autoScrollToSelection) {\n                            gridOptions.api.ensureNodeVisible(rowNode, 'middle');\n                        }\n                    }\n                });\n            }\n            else if (event.event === ui_base_1.EventType.SelectClear ||\n                event.event === ui_base_1.EventType.HoverClear) {\n                gridOptions.api.deselectAll();\n            }\n            else {\n                if (!event.selection) {\n                    selection = self._prevSelection;\n                }\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key]) === utilities_1.getSelectionName(selection)) {\n                        // deselect the node\n                        rowNode.setSelected(false);\n                        // clear the previous selection if it's what we just removed\n                        if (event.selection === self._prevSelection) {\n                            self._prevSelection = undefined;\n                        }\n                    }\n                });\n            }\n        }\n        self._disableCallbacks = false;\n    }\n    setContextMenuItems(columnDefs, contextMenuItems) {\n        if (columnDefs) {\n            if (!contextMenuItems) {\n                contextMenuItems = [];\n            }\n            for (let i = 0; i < columnDefs.length; ++i) {\n                let column = columnDefs[i];\n                column.onCellContextMenu = function (cell) {\n                    context_menu_1.showContextMenu(cell.event, cell, cell.colDef.contextMenuItems ? contextMenuItems.concat(cell.colDef.contextMenuItems) : contextMenuItems);\n                };\n                if (column.children) {\n                    this.setContextMenuItems(column.children, contextMenuItems);\n                }\n            }\n        }\n    }\n    invalidate(options = {}) {\n        let self = this;\n        // make typescript happy to hardcode some things\n        let gridOptions = this._element.gridOptions;\n        // required to allow the select api to not end up in a infinite loop\n        gridOptions.suppressAsyncEvents = true;\n        gridOptions.animateRows = gridOptions.animateRows !== undefined ?\n            gridOptions.animateRows : true;\n        gridOptions.rowSelection = gridOptions.rowSelection !== undefined ?\n            gridOptions.rowSelection : 'multiple';\n        gridOptions.rowDeselection = gridOptions.rowDeselection !== undefined ?\n            gridOptions.rowDeselection : true;\n        gridOptions.suppressScrollOnNewData = gridOptions.suppressScrollOnNewData !== undefined ?\n            gridOptions.suppressScrollOnNewData : true;\n        gridOptions.suppressPropertyNamesCheck = gridOptions.suppressPropertyNamesCheck !== undefined ?\n            gridOptions.suppressPropertyNamesCheck : true;\n        gridOptions.defaultColDef = gridOptions.defaultColDef !== undefined ?\n            gridOptions.defaultColDef : {};\n        gridOptions.defaultColDef.sortable = gridOptions.defaultColDef.sortable !== undefined ?\n            gridOptions.defaultColDef.sortable : true;\n        gridOptions.defaultColDef.resizable = gridOptions.defaultColDef.resizable !== undefined ?\n            gridOptions.defaultColDef.resizable : true;\n        gridOptions.defaultColDef.filter = gridOptions.defaultColDef.filter !== undefined ?\n            gridOptions.defaultColDef.filter : true;\n        gridOptions.autoScrollToSelection = gridOptions.autoScrollToSelection !== undefined ?\n            gridOptions.autoScrollToSelection : true;\n        let wrapCallback = function (userCallback, defaultCallback, eventType) {\n            if (!userCallback) {\n                return defaultCallback;\n            }\n            else {\n                return function (row) {\n                    if (self._disableCallbacks) {\n                        return;\n                    }\n                    userCallback({\n                        caller: self._element,\n                        event: eventType,\n                        data: { row: row.node.data, node: row.node }\n                    });\n                };\n            }\n        };\n        gridOptions.onCellMouseOver = wrapCallback(gridOptions.onCellMouseOver, this.onRowFocusDefaultCallback, ui_base_1.EventType.HoverStart);\n        gridOptions.cellMouseOut = wrapCallback(gridOptions.onCellMouseOver, this.onRowUnfocusDefaultCallback, ui_base_1.EventType.HoverEnd);\n        gridOptions.onRowGroupOpened = wrapCallback(gridOptions.onRowGroupOpened, undefined, undefined);\n        gridOptions.onRowClicked = wrapCallback(gridOptions.onRowClicked, undefined, undefined);\n        gridOptions.onRowDoubleClicked = wrapCallback(gridOptions.onRowDoubleClicked, undefined, undefined);\n        if (gridOptions.onClick) {\n            gridOptions.onRowClicked = wrapCallback(gridOptions.onClick, undefined, undefined);\n        }\n        if (gridOptions.onDoubleClick) {\n            gridOptions.onRowDoubleClicked = wrapCallback(gridOptions.onDoubleClick, undefined, undefined);\n        }\n        if (!gridOptions.onRowSelected) {\n            gridOptions.onRowSelected = this.onRowSelectedDefaultCallback;\n        }\n        else {\n            if (!gridOptions.userOnRowSelected) {\n                gridOptions.userOnRowSelected = gridOptions.onRowSelected;\n            }\n            gridOptions.onRowSelected = function (row) {\n                if (self._disableCallbacks) {\n                    return;\n                }\n                // TODO handle multiple selection clear correctly\n                gridOptions.userOnRowSelected({\n                    caller: self._element,\n                    data: {\n                        row: row.node.data,\n                        node: row.node,\n                        isSelected: row.node.selected\n                    },\n                    event: row.node.selected ? ui_base_1.EventType.SelectAdd : ui_base_1.EventType.SelectRemove\n                });\n            };\n        }\n        let hasGrouping = false;\n        if (gridOptions.rowData && !gridOptions.getNodeChildDetails) {\n            for (let i = 0; i < gridOptions.rowData.length; ++i) {\n                let row = gridOptions.rowData[i];\n                if (row.children && row.children.length > 0) {\n                    hasGrouping = true;\n                    break;\n                }\n            }\n        }\n        if (gridOptions.columnDefs) {\n            let valueCellRendererColumns = [];\n            for (let i = 0; i < gridOptions.columnDefs.length; ++i) {\n                let column = gridOptions.columnDefs[i];\n                if (column.canShowPercentage || column.showAsPercentage || column.showAsBar) {\n                    valueCellRendererColumns.push(column);\n                    column.cellRenderer = valueCellRenderer;\n                    column.comparator = valueComparator;\n                    if (!column.contextMenuItems) {\n                        column.contextMenuItems = [];\n                    }\n                    let idx = 0;\n                    if (column.showAsPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsTotal;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsTotal);\n                            }\n                        }\n                    }\n                    else if (column.canShowPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsPercentage;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsPercentage);\n                            }\n                        }\n                    }\n                }\n                if (column.onCellClicked) {\n                    let onClick = column.onCellClicked;\n                    column.onCellClicked = function (params) {\n                        onClick({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n                if (column.onCellDoubleClicked) {\n                    let onDoubleClick = column.onCellDoubleClicked;\n                    column.onCellDoubleClicked = function (params) {\n                        onDoubleClick({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n            }\n            if (hasGrouping && gridOptions.columnDefs.length > 0) {\n                let groupCol = gridOptions.columnDefs[0];\n                groupCol.cellRenderer = 'agGroupCellRenderer';\n                groupCol.cellRendererParams = {\n                    innerRenderer: (params) => { return params.data[groupCol.field]; },\n                    suppressCount: true\n                };\n                gridOptions.getNodeChildDetails = (rowItem) => {\n                    if (rowItem.children) {\n                        return {\n                            group: true,\n                            expanded: rowItem.expanded,\n                            children: rowItem.children,\n                            key: rowItem[groupCol.field]\n                        };\n                    }\n                    else {\n                        return null;\n                    }\n                };\n            }\n            if (valueCellRendererColumns.length > 0) {\n                computeMaxAndPercentage(gridOptions.rowData, valueCellRendererColumns);\n            }\n        }\n        if (gridOptions.enableSingleKeyboardSelection) {\n            gridOptions.navigateToNextCell = this.keyboardSelectionFocus;\n        }\n        let noContextMenu = gridOptions.contextMenuItems == undefined;\n        if (gridOptions.columnDefs) {\n            for (let i = 0; noContextMenu && i < gridOptions.columnDefs.length; ++i) {\n                let column = gridOptions.columnDefs[i];\n                if (column.contextMenuItems) {\n                    noContextMenu = false;\n                }\n            }\n        }\n        if (!noContextMenu) {\n            this.setContextMenuItems(gridOptions.columnDefs, gridOptions.contextMenuItems);\n        }\n        while (this._div.firstChild) {\n            this._div.removeChild(this._div.firstChild);\n        }\n        if (!this._element.api) {\n            this._element.api = { select: undefined, hover: undefined };\n        }\n        this._element.api.select = function (event) {\n            self.select(event);\n        };\n        this._element.api.hover = this._element.api.select;\n        new agGrid.Grid(this._div, this._element.gridOptions); //create a new grid\n    }\n}\nclass AgGridRenderer {\n    constructor(parent, options = {}, colorMgr = new color_manager_1.ColorManager()) {\n        this.invalidate = this.render;\n        this._parent = parent;\n        this._rendererMap = new WeakMap();\n        this._options = options;\n        this._colorMgr = colorMgr;\n    }\n    getColorManager() {\n        return this._colorMgr;\n    }\n    setOnRenderCallback(callback) {\n        this.onRender = callback;\n    }\n    /** update any options */\n    setOptions(options) {\n        for (let key in options) {\n            this._options[key] = options[key];\n        }\n    }\n    /** @deprecated ('Deprecated since 1.14.0 in favor of focus.  Will be removed in 2.x') */\n    hover(element, event) {\n        this.focus(element, event);\n    }\n    focus(element, event) {\n        console.debug('currently no focus events can be created for the grid');\n    }\n    select(element, event) {\n        if (this._rendererMap.has(element)) {\n            return this._rendererMap.get(element).api.select(event);\n        }\n    }\n    setDiv(element, div) {\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).setDiv(div);\n        }\n    }\n    /**\n     * Render the given element\n     *\n     * @param the element to render\n     */\n    render(element, options = {}) {\n        let self = this;\n        element.renderer = this;\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this, this._parent));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).invalidate(options);\n            if (this.onRender) {\n                this.onRender(element, options);\n            }\n        }\n    }\n    /**\n     * free the resources used by the renderer for this element\n     */\n    destroy(element) {\n        this._rendererMap.delete(element);\n    }\n    getOptions() { return this._options; }\n}\nexports.AgGridRenderer = AgGridRenderer;\n\n\n//# sourceURL=webpack://UWT/./src/core/ag-grid/ag-grid-renderer.ts?");

/***/ }),

/***/ "./src/core/color-manager.ts":
/*!***********************************!*\
  !*** ./src/core/color-manager.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction numberToHex(number) {\n    var hex = Number(number).toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(color) {\n    let rgb = color.substring(color.indexOf('(') + 1, color.indexOf(')')).split(',');\n    return numberToHex(rgb[0]) + numberToHex(rgb[1]) + numberToHex(rgb[2]);\n}\n/** used to organize and create colors for the UI */\nclass ColorManager {\n    constructor(randomColorFunc) {\n        this._colorMap = {};\n        if (randomColorFunc) {\n            this.getRandomColor = randomColorFunc;\n        }\n        else {\n            this.getRandomColor = function () {\n                var letters = '0123456789ABCDEF';\n                var color = '#';\n                for (var i = 0; i < 6; i++) {\n                    color += letters[Math.floor(Math.random() * 16)];\n                }\n                return color;\n            };\n        }\n    }\n    /**\n     * check if an existing color exists for a given key\n     *\n     * @param the key associated with your data\n     */\n    hasColor(key) {\n        return this._colorMap.hasOwnProperty(key);\n    }\n    /**\n     * set the color associated with a given key\n     *\n     * @param key associated with your data\n     * @param color to associate with the key\n     */\n    setColor(key, color) {\n        if (color.indexOf('rgb') === 0) {\n            color = ColorManager.RgbToHex(color);\n        }\n        this._colorMap[key] = color;\n    }\n    /**\n     * get the color associated with a given key\n     *\n     * @param key associated with your data\n     */\n    getColor(key) {\n        if (!this.hasColor(key)) {\n            this._colorMap[key] = this.getRandomColor();\n        }\n        return this._colorMap[key];\n    }\n    static IntToHex(value) {\n        return '#' + value.toString(16).padStart(6, '0');\n    }\n    static RgbToHex(color) {\n        return '#' + rgbToHex(color);\n    }\n    static RgbToInt(color) {\n        return parseInt(rgbToHex(color), 16);\n    }\n}\nexports.ColorManager = ColorManager;\n\n\n//# sourceURL=webpack://UWT/./src/core/color-manager.ts?");

/***/ }),

/***/ "./src/core/context-menu.ts":
/*!**********************************!*\
  !*** ./src/core/context-menu.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction positionMenu(div, rect) {\n    let bodyWidth = document.body.clientWidth;\n    let bodyHeight = document.body.clientHeight;\n    // these points define the top left of our menu\n    let divX = rect.left;\n    let divY = rect.top;\n    // if we draw on the right we do\n    if (rect.right + div.clientWidth < bodyWidth) {\n        divX = rect.right;\n    }\n    else {\n        divX = rect.left - div.clientWidth;\n    }\n    // if we cannot draw down we draw up\n    if (rect.top + div.clientHeight > bodyHeight) {\n        divY = rect.top - div.clientHeight;\n    }\n    div.style.left = (divX - 2) + 'px';\n    div.style.top = (divY - 2) + 'px';\n}\nfunction createMenu(event, data, contextMenuItems, rect, propogateEvent) {\n    let menuDiv;\n    menuDiv = document.createElement('div');\n    menuDiv.setAttribute('class', 'context-menu');\n    menuDiv.oncontextmenu = function (e) {\n        removeMenu();\n        e.preventDefault();\n    };\n    document.body.appendChild(menuDiv);\n    if (contextMenuItems.length > 0) {\n        let menuList = document.createElement('ul');\n        menuDiv.appendChild(menuList);\n        for (let i = 0; i < contextMenuItems.length; ++i) {\n            let item = contextMenuItems[i];\n            let li = document.createElement('li');\n            if (item.divider) {\n                li.className += ' is-divider';\n                li.innerHTML = '<hr>';\n            }\n            else {\n                if (!item.title) {\n                    console.error('No title attribute set. Check the spelling of your options.');\n                }\n                if (item.disabled) {\n                    li.className += ' is-disabled';\n                }\n                if (!item.action && !item.submenu) {\n                    li.className += ' is-header';\n                }\n                if (item.submenu) {\n                    li.innerHTML = `<span><text>${item.title}</text>` +\n                        '<text style=\"width: 5px; float: right; color: #000000A0\">&#9658</text></span>';\n                }\n                else {\n                    li.innerHTML = item.title;\n                }\n                li.onclick = function (d) {\n                    if (item.disabled)\n                        return; // do nothing if disabled\n                    if (!item.action)\n                        return; // headers have no \"action\"\n                    item.action(li, data, i);\n                    removeMenu();\n                };\n                li.onmouseenter = function () {\n                    removeSubmenu(contextMenuItems);\n                    if (item.submenu) {\n                        let relativeRect = li.getBoundingClientRect();\n                        let rect = {\n                            top: relativeRect.top + window.scrollY,\n                            bottom: relativeRect.bottom + window.scrollY,\n                            left: relativeRect.left + window.scrollX,\n                            right: relativeRect.right + window.scrollX,\n                            height: relativeRect.height,\n                            width: relativeRect.width\n                        };\n                        item.submenuDiv = createMenu(event, data, item.submenu, rect, propogateEvent);\n                    }\n                };\n            }\n            menuList.appendChild(li);\n        }\n        menuDiv.style.display = 'block';\n        positionMenu(menuDiv, rect);\n        if (!propogateEvent) {\n            event.stopPropagation();\n        }\n    }\n    return menuDiv;\n}\nfunction removeMenuItem(item) {\n    if (item.submenuDiv) {\n        document.body.removeChild(item.submenuDiv);\n        delete item.submenuDiv;\n    }\n    if (item.submenu) {\n        removeSubmenu(item.submenu);\n    }\n}\nfunction removeSubmenu(items) {\n    items.forEach(function (item, index, items) {\n        removeMenuItem(item);\n    });\n}\nfunction removeMenu() {\n    removeSubmenu(lastMenu);\n    let menus = document.getElementsByClassName('context-menu');\n    while (menus.length) {\n        document.body.removeChild(menus[0]);\n    }\n}\nfunction keyupListener() {\n    window.onkeyup = function (e) {\n        if (e.keyCode === 27) {\n            removeMenu();\n        }\n    };\n}\nlet lastMenu = [];\nfunction showContextMenu(event, data, contextMenuItems, propogateEvent = false) {\n    if (event) {\n        keyupListener();\n        removeMenu();\n        lastMenu = contextMenuItems;\n        createMenu(event, data, contextMenuItems, {\n            left: event.pageX,\n            top: event.pageY,\n            right: event.pageX,\n            bottom: event.pageY,\n            height: 0,\n            width: 0\n        }, propogateEvent);\n        event.preventDefault();\n    }\n}\nexports.showContextMenu = showContextMenu;\n\n\n//# sourceURL=webpack://UWT/./src/core/context-menu.ts?");

/***/ }),

/***/ "./src/core/element-manager.ts":
/*!*************************************!*\
  !*** ./src/core/element-manager.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/core/utilities.ts\");\nconst ui_base_1 = __webpack_require__(/*! ../interface/ui-base */ \"./src/interface/ui-base.ts\");\nvar GroupType;\n(function (GroupType) {\n    GroupType[GroupType[\"Tooltip\"] = 0] = \"Tooltip\";\n    GroupType[GroupType[\"Highlight\"] = 1] = \"Highlight\";\n    GroupType[GroupType[\"Render\"] = 2] = \"Render\";\n    GroupType[GroupType[\"Focus\"] = 3] = \"Focus\";\n    GroupType[GroupType[\"Select\"] = 4] = \"Select\";\n    GroupType[GroupType[\"None\"] = 5] = \"None\";\n})(GroupType || (GroupType = {}));\nclass GroupInfo {\n    constructor() {\n        this._nameMap = {};\n        this._objectMap = new Map();\n    }\n}\nexports.GroupInfo = GroupInfo;\nfunction addTooltipCallback(elem) {\n    if (!elem.getTooltip) {\n        elem.getTooltip = function (event) {\n            if (elem.renderer && elem.renderer.getTooltipData) {\n                return elem.renderer.getTooltipData(elem, event);\n            }\n            return [{ source: elem, group: '', metrics: {} }];\n        };\n    }\n}\nfunction addClickCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.select) {\n        elem.api.select = function (event) {\n            if (elem.renderer && elem.renderer.select) {\n                return elem.renderer.select(elem, event);\n            }\n        };\n    }\n}\nfunction addHoverCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.cursorChange) {\n        elem.api.cursorChange = function (event) {\n            if (elem.renderer && elem.renderer.cursorChange) {\n                return elem.renderer.cursorChange(elem, event);\n            }\n        };\n    }\n    if (!elem.api.focus) {\n        elem.api.focus = function (event) {\n            /** @deprecated ('Deprecated since 1.14.0 in favor of focus.  Will be removed in 2.x') */\n            if (elem.renderer && !elem.renderer.focus && elem.renderer.hover) {\n                return elem.renderer.hover(elem, event);\n            }\n            // end deprecated\n            if (elem.renderer && elem.renderer.focus) {\n                return elem.renderer.focus(elem, event);\n            }\n        };\n        elem.api.hover = elem.api.focus;\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.zoom) {\n        elem.api.zoom = function (event) {\n            if (elem.renderer && elem.renderer.zoom) {\n                return elem.renderer.zoom(elem, event);\n            }\n        };\n    }\n}\nfunction addRenderCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.render) {\n        elem.api.render = function (renderer, options) {\n            if (!renderer) {\n                renderer = elem.renderer;\n            }\n            else {\n                elem.renderer = renderer;\n            }\n            return new Promise(function (resolve, reject) {\n                if (renderer) {\n                    elem.renderer.render(elem, options);\n                    resolve('Ok');\n                }\n                reject('No renderer available');\n            });\n        };\n    }\n}\n/** adds some default callbacks to a given UI object */\nfunction addCallbacks(elem) {\n    addTooltipCallback(elem);\n    addHoverCallback(elem);\n    addClickCallback(elem);\n    addRenderCallback(elem);\n}\nexports.addCallbacks = addCallbacks;\n/** used to group UI elements together.  Can be used to sync\n * selection/tooltips\n */\nclass ElementManager {\n    constructor() {\n        /** the list of elements managed by this manager */\n        this._elems = [];\n        let self = this;\n        this._groupInfo = [];\n        for (let i = 0; i < 5 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n        this._onHoverCallback = function (event) {\n            if (!event.caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes', event);\n            }\n            let elems = self._groupInfo[3 /* Focus */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._hoverCallback) {\n                    self._hoverCallback(elems, event);\n                }\n                else {\n                    for (let i = 0; i < elems.length; ++i) {\n                        let elem = elems[i];\n                        /** @deprecated to remove in 2.x */\n                        if (event.caller !== elem && elem.api && !elem.api.focus && elem.api.hover) {\n                            elem.api.hover(event);\n                        }\n                        // end deprecated\n                        if (event.caller !== elem && elem.api && elem.api.focus) {\n                            elem.api.focus(event);\n                        }\n                    }\n                }\n            }\n        };\n        let dispatch = function (groupType, callback, apiName) {\n            return function (event) {\n                if (!event.caller) {\n                    console.warn('Warning no caller specified for this event, cannot propagate changes', event);\n                }\n                let elems = self._groupInfo[groupType]._objectMap.get(event.caller);\n                if (elems) {\n                    if (callback) {\n                        callback(elems, event);\n                    }\n                    else {\n                        for (let i = 0; i < elems.length; ++i) {\n                            let elem = elems[i];\n                            if (event.caller !== elem && elem.api && elem.api[apiName]) {\n                                elem.api[apiName](event);\n                            }\n                        }\n                    }\n                }\n            };\n        };\n        this._onZoomCallback = dispatch(1 /* Highlight */, this._zoomCallback, 'zoom');\n        this._onCursorChangeCallback = dispatch(1 /* Highlight */, this._cursorChangeCallback, 'cursorChange');\n        this._onBrushCallback = dispatch(1 /* Highlight */, this._brushCallback, 'brush');\n        this._onClickCallback = dispatch(4 /* Select */, this._clickCallback, 'select');\n        this._onTooltipCallback = function (event) {\n            if (!event.caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes', event);\n            }\n            let ret = [];\n            let elems = self._groupInfo[0 /* Tooltip */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._tooltipCallback) {\n                    ret = ret.concat(self._tooltipCallback(elems, event));\n                }\n                else {\n                    for (let i = 0; i < elems.length; ++i) {\n                        let elem = elems[i];\n                        let data = elem.getTooltip(event);\n                        ret = ret.concat(data);\n                    }\n                }\n                if (event.data && event.data.tooltip) {\n                    event.data.tooltip.setData(event.data.tooltip.getTitle(), ret);\n                }\n                return ret;\n            }\n        };\n        this._onUpdateCallback = function (caller, options) {\n            if (!caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes');\n            }\n            let elems = self._groupInfo[2 /* Render */]._objectMap.get(caller);\n            if (elems) {\n                for (let i = 0; i < elems.length; ++i) {\n                    let elem = elems[i];\n                    if (elem.renderer) {\n                        // use the previous renderer\n                        elem.renderer.render(elem, options);\n                    }\n                }\n            }\n        };\n    }\n    removeFromGroup(elem, type) {\n        let list = this._groupInfo[type]._objectMap.get(elem);\n        if (list) {\n            utilities_1.removeFromList(elem, list);\n        }\n    }\n    addToGroup(elem, groupName, type) {\n        if (!this._groupInfo[type]._nameMap.hasOwnProperty(groupName)) {\n            this._groupInfo[type]._nameMap[groupName] = [];\n        }\n        this._groupInfo[type]._nameMap[groupName].push(elem);\n        this._groupInfo[type]._objectMap.set(elem, this._groupInfo[type]._nameMap[groupName]);\n    }\n    /**\n     * add a elem to the manager\n     *\n     * @param elem - the elem that should should be added\n     * @param tooltipGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when showing tooltips.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param highlightGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when doing highlighting.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param renderGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when rerendering.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @return - The elem manager instance.\n     */\n    addElement(elem, tooltipGroupName, highlightGroupName, renderGroupName) {\n        if (!elem) {\n            return this;\n        }\n        let index = this._elems.indexOf(elem);\n        if (index === -1) {\n            addCallbacks(elem);\n            this._elems.push(elem);\n            let renderedElements;\n            if (!elem.getElements) {\n                elem.getElements = function () { return [elem]; };\n            }\n            renderedElements = elem.getElements();\n            for (let i = 0; i < renderedElements.length; ++i) {\n                let renderedElement = renderedElements[i];\n                if (tooltipGroupName) {\n                    this.addToTooltipGroup(renderedElement, tooltipGroupName);\n                }\n                if (highlightGroupName) {\n                    this.addToHighlightGroup(renderedElement, highlightGroupName);\n                }\n                if (renderGroupName) {\n                    this.addToRenderGroup(renderedElement, renderGroupName);\n                }\n            }\n        }\n        else {\n            throw 'Element already exists in this manager';\n        }\n        elem.manager = this;\n        return this;\n    }\n    /**\n     * remove a elem from the manager, removes it from all groups\n     *\n     * @param elem - the elem that should should be removed\n     *\n     * @return - The elem manager instance.\n     */\n    removeElement(elem) {\n        if (!elem) {\n            return this;\n        }\n        let renderedElements;\n        if (elem.getElements) {\n            renderedElements = elem.getElements();\n        }\n        else {\n            renderedElements = [elem];\n        }\n        for (let i = 0; i < renderedElements.length; ++i) {\n            let renderedElement = renderedElements[i];\n            this.removeFromTooltipGroup(renderedElement);\n            this.removeFromHighlightGroup(renderedElement);\n            this.removeFromRenderGroup(renderedElement);\n        }\n        utilities_1.removeFromList(elem, this._elems);\n        delete elem.manager;\n        return this;\n    }\n    /**\n     * Return all the elems in this list\n     * @return the list of elems\n     */\n    getElements() {\n        return this._elems;\n    }\n    /**\n     * user callback called when a tooltip is created\n     *\n     * @param the functiotn to be called\n     */\n    setZoomCallback(callback) {\n        this._zoomCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a hover event happens\n     *\n     * @param the function to be called\n     */\n    setHoverCallback(callback) {\n        this._hoverCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a hover event happens\n     *\n     * @param the function to be called\n     */\n    setClickCallback(callback) {\n        this._clickCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a tooltip is created\n     *\n     * @param the functiotn to be called\n     */\n    setTooltipCallback(callback) {\n        this._tooltipCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a selection event happens\n     *\n     * @param the function to be called\n     */\n    setBrushCallback(callback) {\n        this._brushCallback = callback;\n        return this;\n    }\n    /**\n     * set the group this tooltip is associated with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToTooltipGroup(elem, groupName) {\n        addTooltipCallback(elem);\n        this.removeFromTooltipGroup(elem);\n        this.addToGroup(elem, groupName, 0 /* Tooltip */);\n        let self = this;\n        if (elem.onTooltip) {\n            let func = elem.onTooltip;\n            elem.onTooltip = function (event) {\n                self._onTooltipCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onTooltip = this._onTooltipCallback;\n        }\n        return this;\n    }\n    /**\n     * remove the elem from the tooltip group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromTooltipGroup(elem) {\n        this.removeFromGroup(elem, 0 /* Tooltip */);\n        return this;\n    }\n    /**\n    * set the group to sync this elem with\n    *\n    * @param elem - the elem that should should be \"ganged\"\n    * @param groupName - Name of the group that this elem should be \"ganged\"\n    *   with.\n    *\n    * @return - The elem manager instance.\n    */\n    addToFocusGroup(elem, groupName) {\n        addHoverCallback(elem);\n        this.removeFromFocusGroup(elem);\n        let self = this;\n        if (elem.onHover) {\n            let func = elem.onHover;\n            elem.onHover = function (event) {\n                self._onHoverCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onHover = self._onHoverCallback;\n        }\n        this.addToGroup(elem, groupName, 3 /* Focus */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromFocusGroup(elem) {\n        this.removeFromGroup(elem, 3 /* Focus */);\n        return this;\n    }\n    /**\n    * set the group to sync this elem with\n    *\n    * @param elem - the elem that should should be \"ganged\"\n    * @param groupName - Name of the group that this elem should be \"ganged\"\n    *   with.\n    *\n    * @return - The elem manager instance.\n    */\n    addToSelectGroup(elem, groupName) {\n        addClickCallback(elem);\n        this.removeFromSelectGroup(elem);\n        let self = this;\n        if (elem.onClick) {\n            let func = elem.onClick;\n            elem.onClick = function (event) {\n                self._onClickCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onClick = self._onClickCallback;\n        }\n        this.addToGroup(elem, groupName, 4 /* Select */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromSelectGroup(elem) {\n        this.removeFromGroup(elem, 4 /* Select */);\n        return this;\n    }\n    /**\n     * set the group to sync this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToHighlightGroup(elem, groupName) {\n        addHoverCallback(elem);\n        this.removeFromHighlightGroup(elem);\n        this.addToFocusGroup(elem, groupName);\n        this.addToSelectGroup(elem, groupName);\n        let self = this;\n        if (elem.onBrush) {\n            let func = elem.onBrush;\n            elem.onBrush = function (event) {\n                self._onBrushCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onBrush = self._onBrushCallback;\n        }\n        if (elem.onCursorChanged) {\n            let func = elem.onCursorChanged;\n            elem.onCursorChanged = function (event) {\n                self._onCursorChangeCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onCursorChanged = this._onCursorChangeCallback;\n        }\n        if (elem.onZoom) {\n            let func = elem.onZoom;\n            elem.onZoom = function (event) {\n                self._onZoomCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onZoom = this._onZoomCallback;\n        }\n        let elems = this._groupInfo[1 /* Highlight */]._nameMap[groupName];\n        if (elems && elems.length) {\n            let oldElem = elems[0];\n            if (oldElem.api.getOptions && elem.api && elem.api.zoom) {\n                let options = oldElem.api.getOptions();\n                let zoomEvent = utilities_1.copy(options);\n                zoomEvent.event = ui_base_1.EventType.Zoom;\n                setTimeout(() => {\n                    elem.api.zoom(zoomEvent);\n                });\n            }\n        }\n        this.addToGroup(elem, groupName, 1 /* Highlight */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromHighlightGroup(elem) {\n        this.removeFromFocusGroup(elem);\n        this.removeFromSelectGroup(elem);\n        this.removeFromGroup(elem, 1 /* Highlight */);\n        return this;\n    }\n    /**\n     * set the group to select this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToRenderGroup(elem, groupName) {\n        addRenderCallback(elem);\n        this.removeFromRenderGroup(elem);\n        this.addToGroup(elem, groupName, 2 /* Render */);\n        let self = this;\n        if (elem.handleUpdate) {\n            let func = elem.handleUpdate;\n            elem.handleUpdate = function (caller, options) {\n                self._onUpdateCallback(caller, options);\n                func(caller, options);\n            };\n        }\n        else {\n            elem.handleUpdate = this._onUpdateCallback;\n        }\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromRenderGroup(elem) {\n        this.removeFromGroup(elem, 2 /* Render */);\n        return this;\n    }\n    /** clear all the elements in this list */\n    clear() {\n        this._elems.length = 0;\n        this._groupInfo.length = 0;\n        for (let i = 0; i < 5 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n    }\n}\nexports.ElementManager = ElementManager;\n\n\n//# sourceURL=webpack://UWT/./src/core/element-manager.ts?");

/***/ }),

/***/ "./src/core/utilities.ts":
/*!*******************************!*\
  !*** ./src/core/utilities.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getSelectionName(className) {\n    if (typeof (className) === 'number') {\n        return 'n' + className;\n    }\n    if (!className) {\n        return '';\n    }\n    if (className.length > 0 && !isNaN(Number(className[0]))) {\n        className = 'z' + className;\n    }\n    className = className.replace(/[\\*\\%\\#\\[\\]\\/\\>\\<\\s\\+\\(\\)\\;\\@\\:\\?\\\"=.,]/g, '-');\n    return className;\n}\nexports.getSelectionName = getSelectionName;\nfunction removeFromList(value, arr) {\n    if (value) {\n        let index = arr.indexOf(value);\n        if (index !== -1) {\n            arr.splice(index, 1);\n        }\n    }\n}\nexports.removeFromList = removeFromList;\n/** taken from d3-array */\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n/** taken from d3-array */\nfunction ascendingComparator(f) {\n    return function (d, x) {\n        return ascending(f(d), x);\n    };\n}\n/** modified from d3-array */\nfunction bisect(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisect = bisect;\n/** puts all raw data into buckets based on thresholds and values */\nfunction bucketData(values, thresholds, accessor) {\n    let findRight = bisect().right;\n    let buckets = [];\n    // need one less bucket than thresholds\n    for (let i = 0; i < thresholds.length - 1; ++i) {\n        buckets[i] = [];\n    }\n    let min = thresholds[0];\n    let max = thresholds[thresholds.length - 1];\n    let usedThresholds = thresholds.slice(1);\n    for (let i = 0; i < values.length; ++i) {\n        let compareValue = accessor(values[i]);\n        if (compareValue < min || compareValue > max) {\n            continue;\n        }\n        let valueIdx = findRight(usedThresholds, compareValue);\n        buckets[valueIdx].push(values[i]);\n    }\n    // name the return buckets\n    let ret = {};\n    for (let i = 0; i < thresholds.length - 1; ++i) {\n        let bucketName = thresholds[i] + '-' + thresholds[i + 1];\n        ret[bucketName] = buckets[i];\n    }\n    return ret;\n}\nexports.bucketData = bucketData;\nfunction copy(obj) {\n    let ret = {};\n    for (let key in obj) {\n        ret[key] = obj[key];\n    }\n    return ret;\n}\nexports.copy = copy;\nfunction merge(obj1, obj2) {\n    for (let key in obj2) {\n        obj1[key] = obj2[key];\n    }\n}\nexports.merge = merge;\nfunction convertTraceToTrees(input) {\n    let roots = [];\n    let stack = []; // used to represent the current stack state\n    let nodeStack = []; // used to represent the current stack state\n    for (let i = 0; i < input.length; i++) {\n        let value = input[i];\n        let parent = stack[stack.length - 1];\n        // pop stuff off the stack\n        while (stack.length && value.x > parent.x + parent.dx) {\n            --stack.length;\n            --nodeStack.length;\n            parent = stack[stack.length - 1];\n        }\n        let parentNode = nodeStack[nodeStack.length - 1];\n        let node = {\n            key: value.key,\n            value: value.dx,\n            children: [],\n            parent: parentNode\n        };\n        if (value.name) {\n            node.name = value.name;\n        }\n        if (parentNode) {\n            parentNode.children.push(node);\n        }\n        else {\n            roots.push(node);\n        }\n        stack.push(value);\n        nodeStack.push(node);\n    }\n    return roots;\n}\nexports.convertTraceToTrees = convertTraceToTrees;\nclass SimpleBuffer {\n    constructor(data) {\n        if (data) {\n            this._data = data;\n        }\n        else {\n            this._data = [];\n        }\n    }\n    push(d) {\n        this._data.push(d);\n    }\n    get(index) {\n        return this._data[index];\n    }\n    length() {\n        return this._data.length;\n    }\n    getData() {\n        return this._data;\n    }\n}\nexports.SimpleBuffer = SimpleBuffer;\nclass RingBuffer {\n    constructor(size) {\n        this._data = new Array(size);\n        this._startIdx = 0;\n        this._count = 0;\n        this._isRotating = false;\n    }\n    /** add a new value to the buffer */\n    push(d) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            this._data[this._startIdx] = d;\n            ++this._startIdx;\n            if (this._startIdx === this._count) {\n                this._startIdx = 0;\n            }\n            this._isRotating = true;\n        }\n        else if (this._count === this._data.length - 1) {\n            // here the buffer will start rotating as the buffer is full\n            this._data[this._count] = d;\n            ++this._count;\n            this._isRotating = true;\n        }\n        else {\n            // here the buffer has not been filled yet\n            this._data[this._count] = d;\n            ++this._count;\n        }\n    }\n    /** return the value offset index from the start index\n     * @param index the offset from the start of the buffer\n     */\n    get(index) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            index = index + this._startIdx;\n            if (index >= this._count) {\n                index = index - this._count;\n            }\n        }\n        return this._data[index];\n    }\n    /** get the number of items in the buffer */\n    length() {\n        return this._count;\n    }\n    getData() {\n        if (this._isRotating) {\n            // the buffer is rotating\n            let ret = [];\n            for (let i = this._startIdx; i < this._data.length; ++i) {\n                ret.push(this._data[i]);\n            }\n            for (let i = 0; i < this._startIdx; ++i) {\n                ret.push(this._data[i]);\n            }\n            return ret;\n        }\n        return this._data;\n    }\n}\nexports.RingBuffer = RingBuffer;\nfunction bisectBuffer(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisectBuffer = bisectBuffer;\nfunction transposeKeys(data) {\n    // this is used to map the keys to their indicies in the output summary data\n    let keyIdxMapping = {};\n    function transposeHelper(output, parentKeys, value, level) {\n        let myKeys = [];\n        for (let i = 0; i < parentKeys.length; ++i) {\n            myKeys[i] = parentKeys[i];\n        }\n        myKeys.push(value.key);\n        if (Array.isArray(value.data)) {\n            for (let i = 0; i < value.data.length; ++i) {\n                transposeHelper(output, myKeys, value.data[i], level + 1);\n            }\n        }\n        else {\n            let currSummaryArray = output;\n            for (let keyIdx = myKeys.length - 1; keyIdx >= 0; --keyIdx) {\n                let key = myKeys[keyIdx];\n                let dataIdx;\n                if (!keyIdxMapping.hasOwnProperty(key)) {\n                    dataIdx = currSummaryArray.length;\n                    keyIdxMapping[key] = dataIdx;\n                }\n                else {\n                    dataIdx = keyIdxMapping[key];\n                }\n                // create the summary data if it doesn't exist yet\n                if (!currSummaryArray[dataIdx]) {\n                    currSummaryArray[dataIdx] = { key: key, data: [] };\n                }\n                // if we are the leaf add the data, else just move to the next level\n                if (keyIdx === 0) {\n                    currSummaryArray[dataIdx].data = value.data;\n                }\n                else {\n                    currSummaryArray = currSummaryArray[dataIdx].data;\n                }\n            }\n        }\n    }\n    let output = [];\n    for (let i = 0; i < data.length; ++i) {\n        transposeHelper(output, [], data[i], 0);\n    }\n    return output;\n}\nexports.transposeKeys = transposeKeys;\nfunction runFunctionOnLeaf(node, func) {\n    if (node && node.children && node.children.length > 0) {\n        for (let i = 0; i < node.children.length; ++i) {\n            runFunctionOnLeaf(node.children[i], func);\n        }\n    }\n    else {\n        func(node);\n    }\n}\nexports.runFunctionOnLeaf = runFunctionOnLeaf;\nfunction isOverlapping(rect1, rect2) {\n    return rect1.x <= rect2.right && rect1.right >= rect2.x &&\n        rect1.y <= rect2.bottom && rect1.bottom >= rect2.y;\n}\nexports.isOverlapping = isOverlapping;\n\n\n//# sourceURL=webpack://UWT/./src/core/utilities.ts?");

/***/ }),

/***/ "./src/core/web-utilities.ts":
/*!***********************************!*\
  !*** ./src/core/web-utilities.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst es6_promise_1 = __webpack_require__(/*! es6-promise */ \"es6-promise\");\n/**\n* detect IE\n* returns version of IE or false, if browser is not Internet Explorer\n*/\n// from https://codepen.io/gapcode/pen/vEJNZN\nfunction detectIE() {\n    let ua = window.navigator.userAgent;\n    // Test values; Uncomment to check result …\n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n    // Edge 12 (Spartan)\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n    // Edge 13\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';\n    let msie = ua.indexOf('MSIE ');\n    if (msie > 0) {\n        es6_promise_1.polyfill();\n        if (!String.prototype.startsWith) {\n            String.prototype.startsWith = function (searchString, position) {\n                position = position || 0;\n                return this.substr(position, searchString.length) === searchString;\n            };\n        }\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n    }\n    let trident = ua.indexOf('Trident/');\n    if (trident > 0) {\n        es6_promise_1.polyfill();\n        if (!String.prototype.startsWith) {\n            String.prototype.startsWith = function (searchString, position) {\n                position = position || 0;\n                return this.substr(position, searchString.length) === searchString;\n            };\n        }\n        // IE 11 => return version number\n        let rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n    }\n    let edge = ua.indexOf('Edge/');\n    if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n    }\n    // other browser\n    return false;\n}\nexports.detectIE = detectIE;\ndocument.addEventListener('DOMContentLoaded', function () {\n    0;\n    detectIE();\n}, false);\n// from https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n// polyfill for old version of IE\nfunction useIEPolyfill(window) {\n    try {\n        new CustomEvent('test'); // No need to polyfill\n    }\n    catch (e) {\n        // Polyfills DOM4 CustomEvent\n        let MouseEvent = function (eventType, params) {\n            params = params || { bubbles: false, cancelable: false };\n            var mouseEvent = document.createEvent('MouseEvent');\n            mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            return mouseEvent;\n        };\n        MouseEvent.prototype = Event.prototype;\n        window.MouseEvent = MouseEvent;\n    }\n}\nexports.useIEPolyfill = useIEPolyfill;\n\n\n//# sourceURL=webpack://UWT/./src/core/web-utilities.ts?");

/***/ }),

/***/ "./src/interface/grid.ts":
/*!*******************************!*\
  !*** ./src/interface/grid.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Column {\n    constructor(headerName, field) {\n        this.headerName = headerName;\n        if (!field) {\n            this.field = headerName;\n        }\n        else {\n            this.field = field;\n        }\n    }\n}\nexports.Column = Column;\n\n\n//# sourceURL=webpack://UWT/./src/interface/grid.ts?");

/***/ }),

/***/ "./src/interface/ui-base.ts":
/*!**********************************!*\
  !*** ./src/interface/ui-base.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\n/**\n * Represents a relative alignment\n*/\nvar Alignment;\n(function (Alignment) {\n    Alignment[Alignment[\"Left\"] = 1] = \"Left\";\n    Alignment[Alignment[\"Right\"] = 2] = \"Right\";\n    Alignment[Alignment[\"Top\"] = 4] = \"Top\";\n    Alignment[Alignment[\"Bottom\"] = 8] = \"Bottom\";\n    Alignment[Alignment[\"None\"] = 0] = \"None\";\n})(Alignment = exports.Alignment || (exports.Alignment = {}));\n; // bitmask Position\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"CursorStart\"] = 0] = \"CursorStart\";\n    EventType[EventType[\"CursorMove\"] = 1] = \"CursorMove\";\n    EventType[EventType[\"CursorEnd\"] = 2] = \"CursorEnd\";\n    EventType[EventType[\"BrushStart\"] = 3] = \"BrushStart\";\n    EventType[EventType[\"BrushMove\"] = 4] = \"BrushMove\";\n    EventType[EventType[\"BrushEnd\"] = 5] = \"BrushEnd\";\n    EventType[EventType[\"HoverStart\"] = 6] = \"HoverStart\";\n    EventType[EventType[\"HoverEnd\"] = 7] = \"HoverEnd\";\n    EventType[EventType[\"HoverClear\"] = 8] = \"HoverClear\";\n    EventType[EventType[\"FocusStart\"] = 6] = \"FocusStart\";\n    EventType[EventType[\"FocusEnd\"] = 7] = \"FocusEnd\";\n    EventType[EventType[\"FocusClear\"] = 8] = \"FocusClear\";\n    EventType[EventType[\"SelectAdd\"] = 9] = \"SelectAdd\";\n    EventType[EventType[\"SelectRemove\"] = 10] = \"SelectRemove\";\n    EventType[EventType[\"SelectStart\"] = 9] = \"SelectStart\";\n    EventType[EventType[\"SelectEnd\"] = 10] = \"SelectEnd\";\n    EventType[EventType[\"SelectClear\"] = 11] = \"SelectClear\";\n    EventType[EventType[\"Zoom\"] = 12] = \"Zoom\";\n    EventType[EventType[\"Click\"] = 13] = \"Click\";\n    EventType[EventType[\"DoubleClick\"] = 14] = \"DoubleClick\";\n    EventType[EventType[\"RangeUpdate\"] = 15] = \"RangeUpdate\";\n})(EventType = exports.EventType || (exports.EventType = {}));\nvar UIType;\n(function (UIType) {\n    UIType[UIType[\"Unrendered\"] = 0] = \"Unrendered\";\n    UIType[UIType[\"Cartesian\"] = 1] = \"Cartesian\";\n    UIType[UIType[\"Pie\"] = 2] = \"Pie\";\n    UIType[UIType[\"Grid\"] = 3] = \"Grid\";\n    UIType[UIType[\"FlowDiagram\"] = 4] = \"FlowDiagram\";\n    UIType[UIType[\"ForceDirectedGraph\"] = 5] = \"ForceDirectedGraph\";\n    UIType[UIType[\"Sunburst\"] = 6] = \"Sunburst\";\n    UIType[UIType[\"HierarchyGraph\"] = 7] = \"HierarchyGraph\";\n    UIType[UIType[\"PortDiagram\"] = 8] = \"PortDiagram\";\n    UIType[UIType[\"SimpleGraph\"] = 9] = \"SimpleGraph\";\n    UIType[UIType[\"TreeMap\"] = 10] = \"TreeMap\";\n    UIType[UIType[\"Axis\"] = 11] = \"Axis\";\n    UIType[UIType[\"Radar\"] = 12] = \"Radar\";\n})(UIType = exports.UIType || (exports.UIType = {}));\nvar LegendType;\n(function (LegendType) {\n    LegendType[LegendType[\"Discrete\"] = 0] = \"Discrete\";\n    LegendType[LegendType[\"Gradient\"] = 1] = \"Gradient\";\n})(LegendType = exports.LegendType || (exports.LegendType = {}));\nvar LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation = exports.LegendOrientation || (exports.LegendOrientation = {}));\nvar LegendItemShape;\n(function (LegendItemShape) {\n    LegendItemShape[LegendItemShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    LegendItemShape[LegendItemShape[\"Line\"] = 1] = \"Line\";\n    LegendItemShape[LegendItemShape[\"Circle\"] = 2] = \"Circle\";\n})(LegendItemShape = exports.LegendItemShape || (exports.LegendItemShape = {}));\n// Represents a rectangular area.\nclass Rect {\n    constructor(x, y, width, height) {\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    // Returns true if the rectangle contains (x,y).\n    contains(x, y) {\n        return (x >= this.x && x <= this.x + this.width &&\n            y >= this.y && y <= this.y + this.height);\n    }\n}\nexports.Rect = Rect;\n/**\n * Used to manipulate CSS class and style information\n */\nclass Css {\n    constructor(classes, style) {\n        if (classes) {\n            this.addClasses(classes);\n        }\n        else {\n            this.classes = {};\n        }\n        if (style) {\n            this.style = style;\n        }\n        else {\n            this.style = {};\n        }\n    }\n    /**\n     * add a class to the class list\n     * @param classes to add, can be strings separated by spaces\n     *\n     * @return the manager instance\n     */\n    addClasses(classesStr) {\n        let classes = classesStr.split(' ');\n        for (let i = 0; i < classes.length; ++i) {\n            this.classes[classes[i]] = true;\n        }\n        return this;\n    }\n    /**\n     * add a set of styles to the style object\n     * @param style a style object\n     *\n     * @return the manager instance\n     */\n    addStyles(style) {\n        for (let key in style) {\n            this.style[key] = style[key];\n        }\n        return this;\n    }\n    /** set the color value\n     *\n     * @param color a string representing the color to use\n     */\n    setColor(color) {\n        this.addStyles({ color: color });\n        return this;\n    }\n    /** set the opcaity value\n     *\n     * @param opcaity a string representing the color to use\n     */\n    setOpacity(opacity) {\n        this.addStyles({ opacity: opacity });\n        return this;\n    }\n    /**\n     * remove a class from the class list\n     * @param className the class to remove\n     *\n     * @return the manager instance\n     */\n    removeClass(className) {\n        delete this.classes[className];\n        return this;\n    }\n    /**\n     * remove a style from the style map\n     * @param key the name of the style to remove\n     *\n     * @return the manager instance\n     */\n    removeStyle(key) {\n        delete this.style[key];\n        return this;\n    }\n    /**\n     * get the list of classes\n     *\n     * @return a list of classes for this manager\n     */\n    getClasses() {\n        return Object.keys(this.classes);\n    }\n    /**\n     * helper to get a space separated list of classes\n     *\n     * @return a string list of classes for this manager\n     */\n    getClassString() {\n        let ret = '';\n        for (let className in this.classes) {\n            ret += className + ' ';\n        }\n        return ret;\n    }\n    /**\n     * get the style map\n     *\n     * @return an object that contains key/value style pairs\n     */\n    getStyles() {\n        return this.style;\n    }\n    /**\n     * helper to get a json representation of the style map\n     *\n     * @return the json string of the style map\n     */\n    getStyleString() {\n        return JSON.stringify(this.style);\n    }\n}\nexports.Css = Css;\n;\n/**\n * implemented a basic API on top of the IRange object\n */\nclass Range {\n    constructor(min, max) {\n        this.min = min;\n        this.max = max;\n    }\n    /**\n     * set the min value for the range\n     *\n     * @return the min range value\n     */\n    setMin(min) {\n        this.min = min;\n        return this;\n    }\n    /**\n     * get the min value for the range\n     *\n     * @return the min range value\n     */\n    getMin() {\n        return this.min;\n    }\n    /**\n     * set the max value for the range\n     *\n     * @return the max range value\n     */\n    setMax(max) {\n        this.max = max;\n        return this;\n    }\n    /**\n     * get the max value for the range\n     *\n     * @return the max range value\n     */\n    getMax() {\n        return this.max;\n    }\n}\nexports.Range = Range;\n\n\n//# sourceURL=webpack://UWT/./src/interface/ui-base.ts?");

/***/ }),

/***/ "ag-grid-community":
/*!***************************************************************************************************************************!*\
  !*** external {"root":"agGrid","commonjs2":"ag-grid-community","amd":"ag-grid-community","commonjs":"ag-grid-community"} ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_ag_grid_community__;\n\n//# sourceURL=webpack://UWT/external_%7B%22root%22:%22agGrid%22,%22commonjs2%22:%22ag-grid-community%22,%22amd%22:%22ag-grid-community%22,%22commonjs%22:%22ag-grid-community%22%7D?");

/***/ }),

/***/ "es6-promise":
/*!******************************!*\
  !*** external "es6-promise" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_es6_promise__;\n\n//# sourceURL=webpack://UWT/external_%22es6-promise%22?");

/***/ })

/******/ });
});